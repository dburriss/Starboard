[{"uri":"/Starboard/index.html","title":"Starboard Docs Home","content":"---\ntitle: Starboard Docs Home\n---\n# Starboard\n\nStarboard is a library providing strongly typed builders over kubernetes configuration. It allows you to retain a declarative style to your configuration while putting the full power of the F# programming language in your hands.\n\nStarboard outputs plain Kubernetes YAML or JSON resource config files, so no need to change what you already have.\n\n## Why?\n\nDefining infrastructure as code can get complicated. Infrastructure code can run up to thousands of lines of configuration files. We then add layer upon layer of tools on top of this to manage the complexity while trying to keep our structured text correct and understandable.\n\nThe problems being solved by layers of tooling on top of mountains of yaml are the following:\n\n- control flow\n- sharing\n- templating\n- packaging\n\nThese are all problems that mature languages have solved decades ago. Instead of layering new tools on top of YAML files, what if we instead used a declarative programming language to define our configuration? Starboard enables this approach for Kubernetes.\n\n## Feature summary\n\n- A familiar declarative style\n- The full power of a proper programming language (it\u0027s just F#, no magic)\n- Built-in validations for quick feedback\n- Outputs to Kubernetes YAML or JSON config\n- Strongly typed for reduced mistakes\n- Supported by your favourite IDE (it\u0027s just F# after all)\n- Sane defaults for authentication and resource constraints\n\n## Getting started\n\nShow me the code! \n\nOf course. Say we have a file called \u0060infra.fsx\u0060.\n\n\u0060\u0060\u0060fsharp\n// infra.fsx\n// include the Starboard package from Nuget\n#r \u0022nuget:Starboard\u0022\n\n// open  the namespaces for the resources you need\nopen Starboard.Common\nopen Starboard.Workloads\n\n// define the deployment Kubernetes resource\nlet theDeployment = k8s {\n    deployment {\n        \u0022my-starboard-deployment\u0022\n        replicas 2\n        add_matchLabel (\u0022app\u0022, \u0022nginx\u0022)\n        pod {\n            _labels [(\u0022app\u0022, \u0022nginx\u0022)]\n            container {\n                name \u0022nginx\u0022\n                image \u0022nginx:latest\u0022\n            }\n        }\n    }\n}\n\n// write your YAML file to disk\nKubeCtlWriter.toYamlFile theDeployment \u0022deployment.yaml\u0022\n\u0060\u0060\u0060\n\nThat\u0027s it! You now have a kubernetes config file for a deployment.\n\n\u0060\u0060\u0060bash\ndotnet fsi infra.fsx\nkubectl apply -f deployment.yaml\n\u0060\u0060\u0060\n\nReady to try it yourself? Try the [hello-world](tutorials/hello-world.fsx) tutorial. To explore more examples, check out the *How-to* or *Tutorials* section.\n\n## Example use-cases\n\n1. Template out repeat config as a function. See the [Generate dynamic config](4_generate-dynamic-config.fsx) how-to.\n2. Fetch data from databases, APIs, environment variables, git, or wherever else to generate Kubernetes config.\n3. Package up common infrastructure patterns and ship them to teams as Nuget packages.\n4. Easily build CLI tools to output collections of Kubernetes config for development teams.\n5. Let your imagination ship out.\n\n## About this documentation\n\nThe docs follow the guidance from [The documentation system](https://documentation.divio.com/).\n\n## About the logo\n\nShip by Aleksandr Vector from \u003Ca href=\u0022https://thenounproject.com/browse/icons/term/ship/\u0022 target=\u0022_blank\u0022 title=\u0022Ship Icons\u0022\u003ENoun Project\u003C/a\u003E"},{"uri":"/Starboard/3_working-with-metadata.html","title":"Working with metadata","content":"(**\n---\ntitle: Working with metadata\ncategory: How-to\ncategoryindex: 2\nindex: 3\n---\n*)\n\n(**\n# Working with metadata\n\nSetting metadata like \u0060name\u0060, \u0060namespace\u0060, \u0060labels\u0060, and \u0060annotations\u0060 are a common part of defining a Kubernetes resource.\n*)\n\n(*** hide ***)\n// import from Nuget\n#r \u0022nuget:YamlDotNet\u0022\n#r \u0022nuget:Newtonsoft.Json\u0022\n#r \u0022../src/Starboard/bin/debug/net6.0/Starboard.dll\u0022\n\n// open the required namespaces\n\nopen Starboard\nopen Starboard.Common\nopen Starboard.Workload\n\n(*** show ***)\n// Using an inline metadata builder\nk8s {\n    deployment {\n        metadata {\n            name \u0022my-name\u0022\n            ns \u0022my-namespace\u0022 // \u0060ns\u0060 used since namespace is a keyword in F#\n            labels [\u0022label1\u0022, \u0022value1\u0022]\n            annotations [\u0022annotation-key\u0022, \u0022annotation-value\u0022]\n        }\n    }\n}\n\n(**\nIt is of course always possible to pass in a variable instead.\n*)\n// Assign the builder result to a variable first\nlet meta = metadata {\n            name \u0022my-name\u0022\n            ns \u0022my-namespace\u0022\n            labels [\u0022label1\u0022, \u0022value1\u0022]\n            annotations [\u0022annotation-key\u0022, \u0022annotation-value\u0022]\n        }\nk8s {\n    deployment {\n        set_metadata meta\n    }\n}\n\n(**\nA **convention** that is enabled is that you can set the metadata on a resource using any of the following operations \u0060_name\u0060, \u0060_namespace\u0060, \u0060_labels\u0060, and \u0060_annotations\u0060\n*)\n\n// use the _ convention\nk8s {\n    deployment {\n        _name \u0022my-name\u0022\n        _namespace \u0022my-namespace\u0022\n        _labels [\u0022label1\u0022, \u0022value1\u0022]\n        _annotations [\u0022annotation-key\u0022, \u0022annotation-value\u0022]\n    }\n}\n\n(**\nAnother **convention** is that instead of using \u0060_name\u0060 you can drop a string into the body of most resources and it will be assigned to the \u0060metadata.name\u0060 property. This also works for some data that does not have metadata but has a name property.\n*)\n\n// use the _ convention\nk8s {\n    deployment {\n        \u0022my-name\u0022 // \u003C- No operation specified\n        _labels [\u0022label1\u0022, \u0022value1\u0022]\n    }\n}\n\n(**\nOne last neat trick for metadata and many other resources is that you can just drop the variable into the body of the builder. For this to work, the type of the variable must be unique to a single field on the builder.\n*)\n\nlet deploymentMetadata = \n        metadata {\n            name \u0022my-name\u0022\n            ns \u0022my-namespace\u0022\n            labels [\u0022label1\u0022, \u0022value1\u0022]\n            annotations [\u0022annotation-key\u0022, \u0022annotation-value\u0022]\n        }\n\n// use the _ convention\nk8s {\n    deployment {\n        deploymentMetadata // \u003C- just drop the variable in the resource expression\n    }\n}\n\n(**\nSo there are many ways to define your metadata. I suggest you decide for one on your project and use that method throughout.\n*)"},{"uri":"/Starboard/1_setup-environment.html","title":"Setup your environment","content":"(**\n---\ntitle: Setup your environment\ncategory: How-to\ncategoryindex: 2\nindex: 1\n---\n*)\n\n(**\n# Setup F# scripting\n\n## Install dotnet SDK\n\nTo work with Starboard you will need to be able to create, edit, and run F# script files (.fsx). This page will give you a quick-start on how to get setup as well as links to resources for further reading if you would like to deepen your knowledge.\nRunning fsx files requires FSharp Interactive (FSI) which is bundled as part of the [dotnet SDK](https://dotnet.microsoft.com/en-us/download).\n\nThat is it! You can now run F# script files.\n\nTo enter FSI: \u0060dotnet fsi\u0060\n\nTo run a script: \u0060dotnet fsi /path/to/script.fsx [optional argument]\u0060\n\n## Setup an editor\n\nIf you are using VS Code, you can install the [Ionide plugin](https://ionide.io/Editors/Code/getting_started.html) to get get you going. Just search for Ionide on the VS Code extensions marketplace. Alternatively you can use Visual Studio, Rider, or NeoVim (with the [Ionide plugin](https://ionide.io/Editors/Vim/overview.html)).async\n\nIonide has a handy run button for executing your script right from the IDE.\n\n## Use Starboard\n\nTo get started using Starboard, all you need to do is include the following line in a fsx file:\n\n\u0060#r \u0022nuget: Starboard\u0022\u0060\n*)"},{"uri":"/Starboard/2_generating-kubernetes-config.html","title":"Generating Kubernetes config","content":"(**\n---\ntitle: Generating Kubernetes config\ncategory: How-to\ncategoryindex: 2\nindex: 2\n---\n*)\n\n(**\n# Generating Kubernetes config\n\nStarboard gives a powerful way to define your Kubernetes config but for that to be useful, we need to generate the kubernetes config. Starboard provides some helpers for doing just this in \u0060cref:T:Starboard.K8s.KubeCtlWriter\u0060.\n*)\n(*** hide ***)\n// import from Nuget\n#r \u0022nuget:YamlDotNet\u0022\n#r \u0022nuget:Newtonsoft.Json\u0022\n#r \u0022../src/Starboard/bin/debug/net6.0/Starboard.dll\u0022\n\n// open the required namespaces\n\nopen Starboard\nopen Starboard.Common\nopen Starboard.Workload\n\n(*** show ***)\nlet kubeConfig = k8s {\n    deployment {\n        \u0022my-name\u0022 // \u003C- No operation specified\n        _labels [\u0022label1\u0022, \u0022value1\u0022]\n    }\n}\n\n(**\n## Printing to screen\n\nIf you would like to see what is generated on your screen you can use the \u0060cref:T:Starboard.K8s.KubeCtlWriter.print\u0060 function. \n\n\u003E Note that the print also prints any validation errors.\n*)\n\nKubeCtlWriter.print kubeConfig\n(*** hide ***)\nlet k8sOutput\u0027 = KubeCtlWriter.toYaml kubeConfig\nk8sOutput\u0027.content\n(*** include-it ***)\n(**\n## Writing to file\n\nIf you would like to save your \u0060cref:T:Starboard.K8s\u0060 config to file, you can use either the \u0060cref:T:Starboard.K8s.KubeCtlWriter\u0060\u0060.toJsonFile\u0060 or \u0060cref:T:Starboard.K8s.KubeCtlWriter\u0060\u0060.toYamlFile\u0060 function.\nAs the names imply, these will save your config as JSON or YAML respectively.\n*)\n\n(**\n\u0060\u0060\u0060fsharp\nKubeCtlWriter.toYamlFile kubeConfig \u0022deployment.yaml\u0022\n\u0060\u0060\u0060\n*)\n\n(**\n## Getting the content\n\nYou can also get the \u0060cref:T:Starboard.K8s.K8sOutput\u0060, which gives you access to not only the JSON or YAML \u0060cref:T:Starboard.K8s.K8sOutput\u0060\u0060.content\u0060, but also to the \u0060cref:T:Starboard.K8s.K8sOutput\u0060\u0060.errors\u0060. \nThis is an array of validation errors that Starboard has found in the schema. Starboard prevents many schema issues by being strongly typed but it also runs validation on values that should not be empty or should follow certain formatting.\nIt will still generate the config you specify but gives you errors that you can check before submitting the config to a Kubernetes cluster.\n*)\n\n\nlet k8sOutput = KubeCtlWriter.toYaml kubeConfig\nk8sOutput.content\n(*** include-it ***)\n\n(**\n## Validation errors\n\nAs mentioned, \u0060cref:T:Starboard.K8s.K8sOutput\u0060 contains an \u0060errors\u0060 field that contains a list of validation errors.\n\nEach \u0060cref:T:Starboard.ValidationProblem\u0060 has a \u0060Message\u0060 field on it that gives back a \u0060string\u0060. You can print these errors out:\n*)\n\nk8sOutput.errors \n|\u003E List.map (fun err -\u003E err.Message)\n|\u003E List.iter (eprintfn \u0022%s\u0022)"},{"uri":"/Starboard/4_generate-dynamic-config.html","title":"Generate dynamic config","content":"(**\n---\ntitle: Generate dynamic config\ncategory: How-to\ncategoryindex: 2\nindex: 4\n---\n*)\n\n(**\n# Generate dynamic config\n\nThe real power of Starboard is not only the awesome declarative builder syntax enabled by F# but also that we can leverage the full power of a programming language instead of some hacky templating language. \n\nIn the example below we define a function that defines a **deployment** and a **service** based on the application _name_ and _port_ number passed to the function. \n\nThe function nomalizes the name by lowercasing it and stripping any special characters from it. This is a great way to standardize on naming conventions without always requiring that everyone always remembers the standards.\n*)\n(*** hide ***)\n#r \u0022nuget:YamlDotNet\u0022\n#r \u0022nuget:Newtonsoft.Json\u0022\n#r \u0022../src/Starboard/bin/debug/net6.0/Starboard.dll\u0022\n(*** show ***)\nopen System\nopen Starboard\nopen Starboard.Common\nopen Starboard.Workload\nopen Starboard.Service\n\n/// Returns a deployment and service for \u0060appName\u0060\nlet publicApi appName portNumber =\n    /// Lowercase the name and allow only letters and digits\n    let normalize (name: string) =\n        name.ToLowerInvariant().ToCharArray() \n        |\u003E Array.filter Char.IsLetterOrDigit\n        |\u003E String\n    let normalizedName = normalize appName\n    let matchOn = (\u0022app\u0022, normalizedName)\n    k8s {\n        deployment {\n            $\u0022{normalizedName}-deploy\u0022\n            _labels [matchOn]\n            replicas 2\n            add_matchLabel (\u0022app\u0022, normalizedName)\n            pod {\n                $\u0022{normalizedName}-pod\u0022\n                _labels [matchOn]\n                container {\n                    \u0022nginx\u0022\n                    image \u0022nginx\u0022\n                }\n            }\n        }\n        service {\n            $\u0022{normalizedName}-service\u0022\n            _labels [matchOn]\n            typeOf ServiceType.NodePort\n            matchLabel matchOn\n            servicePort {\n                port portNumber\n                protocol Protocol.TCP\n            }\n        }\n    }\n\n// Use the \u0060publicApi\u0060 function to create 2 lists or resources and combine them into a new \u0060K8s\u0060 instance. \nlet k8sConfig = k8s {\n    publicApi \u0022Checkout\u0022 80\n    publicApi \u0022Payments\u0022 81\n }\n\n// Get the output content and validation errors\nlet k8sOutput = KubeCtlWriter.toYaml k8sConfig\n(*** hide ***)\nlet md = $\u0022\n{k8sOutput.content}\n\u0022\n(**\n### Output\n*)\n(*** include-value: md ***)"},{"uri":"/Starboard/tutorials/hello-world.html","title":"Hello world","content":"(**\n---\ntitle: Hello world\ndescription: Generate your first Deployment\ncategory: Tutorials\ncategoryindex: 3\nindex: 1\n---\n*)\n\n(**\n# Starboard: Hello world\n\nIn this tutorial we will create your first Starboard script and generate the Kubernetes YAML config to a file.\n\n## Requirements\n\n1. A [Kubernetes cluster to learn on](https://kubernetes.io/docs/tasks/tools/) such as Kubernetes on Docker or minikube.\n2. A basic knowledge of using [kubectl](https://kubernetes.io/docs/reference/kubectl/)\n3. [dotnet SDK]() installed\n4. Optionally, any IDE that supports F# (Visual Studio Code, IntelliJ Rider, Visual Studio, NeoVim)\n\n\u003E Visual Studio Code with the [Ionide](https://ionide.io/) is a great choice. See [Setup your environment](../setup-environment.fsx) for more details.\n\n## Initial configuration\n\nCreate a F# script file called \u0060deployment.fsx\u0060\n\nCopy the following code into the script file:\n*)\n\n// TODO: import from Nuget\n#r \u0022nuget:YamlDotNet\u0022\n#r \u0022nuget:Newtonsoft.Json\u0022\n#r \u0022../../src/Starboard/bin/debug/net6.0/Starboard.dll\u0022\n\n// open the required namespaces\nopen Starboard\nopen Starboard.Common\nopen Starboard.Workload\n\n// define your k8s config\nlet theInvalidDeployment = k8s {\n    deployment {\n        pod {\n            container {\n                name \u0022nginx\u0022\n                image \u0022nginx:latest\u0022\n                workingDir \u0022/test-dir\u0022\n            }\n        }\n    }\n}\n\n// Write the YAML to infra.yaml file and get the list of validation issues\nlet validations = KubeCtlWriter.toYamlFile theInvalidDeployment \u0022hello-world.yaml\u0022\n// Let\u0027s print out the validation errors\nfor err in validations do\n    eprintfn \u0022%s\u0022 err.Message\n\n(*** hide ***)\nlet output1 = KubeCtlWriter.toYaml theInvalidDeployment\nlet errorOutput1 = \n    output1.errors \n    |\u003E List.map (fun err -\u003E err.Message)\n    |\u003E List.toSeq \n    |\u003E fun arr -\u003E String.concat (System.Environment.NewLine) arr\n(**\n### Output\n*)\n(*** include-value: errorOutput1 ***)\n\n(**\n\nNow you can call the fsx file to generate your YAML config.\n\n\u0060\u0060\u0060bash\ndotnet fsi deployment.fsx\n\u0060\u0060\u0060\n\nIf you run the apply command on your YAML file, you will see Kubernetes agrees with the validation errors.\n\n\u0060\u0060\u0060bash\nkubectl apply -f hello-world.yaml\n\u0060\u0060\u0060\n\n## Fixed config\n\nLet\u0027s address the validation errors that Starboard found. \n\n1. Call the \u0060add_matchLabel\u0060 operation with a key/value pair for the label. \n2. Next, add the label to the pod using the \u0060_labels\u0060 metadata operation, passing in a list of key/value pairs.\n\n*)\n\nlet theValidDeployment = k8s { \n    deployment {\n        \u0022test-deployment\u0022\n        replicas 2\n        add_matchLabel (\u0022app\u0022, \u0022nginx\u0022) // \u003C- fix the validation error\n        pod {\n            _labels [(\u0022app\u0022, \u0022nginx\u0022)] // \u003C- fix the validation error\n            container {\n                name \u0022nginx\u0022\n                image \u0022nginx:latest\u0022\n                workingDir \u0022/test-dir\u0022\n            }\n        }\n    }\n}\n\nKubeCtlWriter.toYamlFile theValidDeployment \u0022hello-world.yaml\u0022\n(*** hide ***)\nlet output2 = KubeCtlWriter.toYaml theValidDeployment\nlet content2 = output2.content\n(**\n### Output\n\nOur validation errors are gone and we have a valid Kubernetes configuration.\n*)\n(*** include-value: content2 ***)\n\n(**\n## Testing the result\n\nLet\u0027s execute this deployment against our Kubernetes cluster to confirm it is indeed correct.\n\n\u0060\u0060\u0060bash\ndotnet fsi deployment.fsx\nkubectl apply -f hello-world.yaml\nkubectl get deployments\n\u0060\u0060\u0060\n\nYou should get the message: _deployment.apps/test-deployment created_\n\n## Summary\n\nIn this tutorial you created your first Starboard script and generated the YAML. We saw how to get and print out the validation errors.\nFinally, we saw how we can successfully deploy our generated script.\n\nCongratulations! You have taken a turn toward a new way of configuring your infrastructure.\n*)\n"},{"uri":"/Starboard/tutorials/guestbook.html","title":"Guestbook","content":"(**\n---\ntitle: Guestbook\ndescription: A guestbook PHP web app and Redis\ncategory: Tutorials\ncategoryindex: 3\nindex: 2\n---\n*)\n\n(**\n# Starboard: Guestbook Go\n\nIn this tutorial we will recreate the [official Kubernetes Guestbook example](https://kubernetes.io/docs/tutorials/stateless-application/guestbook/). \nThe example deploys a Redis cluster with a master node and 3 replicas. A PHP web application makes use of the Redis cluster to allow a guest to leave a note.\n\n\u003E The official example does not currently work if you run it as is but don\u0027t worry. We will make adjustments to make sure our deployment runs as expected.\n\nThis tutorial will also start to show the power of using a programming language over static configuration.\n\n## Topics covered\n\n- Parametrizing and reusing configurations by using functions\n- [Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)\n- [Services](https://kubernetes.io/docs/reference/kubernetes-api/service-resources/service-v1/)\n\n## Requirements\n\n1. A [Kubernetes cluster to learn on](https://kubernetes.io/docs/tasks/tools/) such as Kubernetes on Docker or minikube.\n1. A basic knowledge of using [kubectl](https://kubernetes.io/docs/reference/kubectl/)\n1. [Ingress enabled](https://kubernetes.github.io/ingress-nginx/deploy/) for your clusterW\n1. [dotnet SDK](https://dotnet.microsoft.com/en-us/) installed\n1. Optionally, any IDE that supports F# (Visual Studio Code, IntelliJ Rider, Visual Studio, NeoVim)\n\n\u003E Visual Studio Code with the [Ionide](https://ionide.io/) is a great choice. See [Setup your environment](../setup-environment.fsx) for more details.\n\n## Configuring a Redis Deployment\n\nIn the [Hello World tutorial](hello-world.fsx) you nested in-line the config. Here we will be defining each resource and assign it to a variable. \nWe then build up our Deployment using the variables rather than in-lining the config.\n\nFirst off, import the Starboard package and import the namespaces we need.\n\n1. Create a file called \u0060guestbook.fsx\u0060\n2. Use the \u0060#r\u0060 directive to import the Starboard package and open up the namespaces\n*)\n// TODO: import from Nuget\n#r \u0022nuget:YamlDotNet\u0022\n#r \u0022nuget:Newtonsoft.Json\u0022\n#r \u0022../../src/Starboard/bin/debug/net6.0/Starboard.dll\u0022\n\n// open the required namespaces\nopen System\nopen Starboard\nopen Starboard.Common\nopen Starboard.Workload\nopen Starboard.Service\n\n(**\nThe we are going to create our first function. This function, \u0060redisDeployment\u0060 will return the Deployment resource configuration.\nA [F# function](https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/) is just a value, so we use the \u0060let\u0060 keyword to assign the value.\n\n\u003E Tip: Start with defining your configuration with hard-coded values, then pull our parameters to pass in as arguments as needed.\n*)\n\n/// Return a Redis Kubernetes Deployment Resource Config\nlet redisDeployment redisName role replicaCount portNumber  =\n    \n    // which image depends on the role\n    let redisImage = if role = \u0022leader\u0022 then \u0022docker.io/redis:6.0.5\u0022 else \u0022gcr.io/google_samples/gb-redis-follower:v2\u0022//\u0022k8s.gcr.io/redis:e2e\u0022 \u0022k8s.gcr.io/redis-slave:v2\u0022\n\n    // define the container\n    let redisContainer = container {\n        name redisName\n        image redisImage\n        containerPort {\n            port portNumber\n        }\n    }\n\n    // build up the list of labels\n    let labels = [\n        (\u0022app\u0022, \u0022redis\u0022)\n        (\u0022role\u0022, role)\n        (\u0022tier\u0022, \u0022backend\u0022)\n    ]\n\n    // the pod to use for podTemplate\n    let redisPod = pod {\n        _labels labels\n        add_container redisContainer\n    }\n\n    // define the deployment using the same labels used for the pod in the matchLabels\n    let redisDeployment = deployment {\n        _name redisName\n        replicas replicaCount\n        add_matchLabels labels\n        podTemplate redisPod\n    }\n\n    // return the deployment config\n    redisDeployment\n\n(**\n\nSo now we have a function that can return the config for both our master and replica Redis deployments.\n\n## Configuring a Redis Service\n\nNext we need to have a Service to match up to a Deployment. This Service will proxy the traffic to the Redis pods provisioned through the Deployment.empty\n\nWe do this the same way as with the Deployment. With a function called \u0060redisService\u0060.\n\n*)\n\n/// Return a Redis Kubernetes Service Resource Config\nlet redisService serviceName role portNumber =\n    // list the labels\n    let labels = [\n        (\u0022app\u0022, \u0022redis\u0022)\n        (\u0022role\u0022, role)\n        (\u0022tier\u0022, \u0022backend\u0022)\n    ]\n\n    // configure the port\n    let port = servicePort {\n        port portNumber\n        targetPortInt portNumber\n    }\n\n    // put it together in a Service config\n    let redisService = service {\n        _name serviceName\n        _labels labels\n        add_port port\n        matchLabels labels\n    }\n\n    // return the config\n    redisService\n\n(**\n\nThis function will provide the Service config when passed the parameters for the service. We can use this for defining a Service for both the master and replica Redis Deployments.\n\n## Configuring the Guestbook\n\nThe last piece of the puzzle is the web application. \nThe image we are pulling in is of a PHP application but Kubernetes doesn\u0027t really care what it is. \nWe just define the image used by the container in the Pod.\n\nSo we define a general function for returning the config for a Deployment of an application and the Service to make it available.\n\n*)\n\n/// Return a Deployment and Service for a frontend application connected to Redis\nlet frontendApp appName imageName replicaCount portName portNumber=\n    // pass back a K8s config type (contains both Deployment and Service)\n    k8s {\n        // add deployment to K8s config\n        deployment {\n            _name appName\n            replicas replicaCount\n            labelSelector {\n                matchLabels [\n                    (\u0022app\u0022, appName)\n                    (\u0022tier\u0022, \u0022frontend\u0022)\n                ]\n            }\n            pod {\n                _labels [\n                    (\u0022app\u0022, appName)\n                    (\u0022tier\u0022, \u0022frontend\u0022)\n                ]\n                container {\n                    appName\n                    image imageName\n                    add_port (containerPort {\n                        name portName\n                        port portNumber\n                    })\n                    cpuRequest 100\u003Cm\u003E\n                    memoryRequest 100\u003CMi\u003E\n                    // environment variables instructing how to find Redis cluster\n                    envVar {\n                        name \u0022GET_HOSTS_FROM\u0022\n                        value \u0022dns\u0022\n                    }\n                }\n            }\n        } \n\n        // add service to K8s config\n        service {\n            _name appName\n            _labels [\n                (\u0022app\u0022, appName)\n                (\u0022tier\u0022, \u0022frontend\u0022)\n            ]\n            add_port (servicePort {\n                        port portNumber\n                        targetPortString portName\n                    })\n            matchLabels [\n                (\u0022app\u0022, appName)\n                (\u0022tier\u0022, \u0022frontend\u0022)\n            ]\n            typeOf NodePort\n        }\n    } // F# returns the last expression of a function. Since the k8s definition is a single expression, it is returned.\n\n(**\n\nIn the above function we used a different style to the previous 2. We defined the configuration in a single expression without assigning labels and pods to intermediate variables.\nWhich style you use is up to you and might depend on the complexity of the configuration or you might chose variables for reuse (eg. labels are a common candidate).\n\n## Putting it together\n\nNow that we have our functions, we need the values we will be passing into them.  \n*)\n\n// Capture our values for the Redis and App config\n// Redis settings\nlet leaderName = \u0022redis-leader\u0022\nlet leaderRole = \u0022leader\u0022\nlet leaderReplicaCount = 1\nlet followerName = \u0022redis-follower\u0022\nlet followerRole = \u0022follower\u0022\nlet followerReplicaCount = 2\nlet redisPortNumber = 6379\n// Guestbook settings\nlet guestbookAppName = \u0022guestbook\u0022\nlet guestbookAppImage = \u0022gcr.io/google-samples/gb-frontend:v5\u0022\nlet guestbookReplicas = 3\nlet guestBookPortName = \u0022http-server\u0022\nlet guestBookPortNumber = 80\n\n(**\nNow we put together our final Kubernetes configuration by generating the config by calling the functions we created above. We compose them in a \u0060k8s\u0060 builder to build up our final configuration.\n*)\n\n// build up the config by calling the functions\nlet k8sConfig = k8s {\n    // Redis master deployments and service\n    redisDeployment leaderName leaderRole leaderReplicaCount redisPortNumber\n    redisService leaderName leaderRole redisPortNumber\n    // Redis replica deployment and service\n    redisDeployment followerName followerRole followerReplicaCount redisPortNumber\n    redisService followerName followerRole redisPortNumber\n    // Guestbook app (combines that K8s instance with the current one)\n    frontendApp guestbookAppName guestbookAppImage guestbookReplicas guestBookPortName guestBookPortNumber\n}\n\n(**\nWe use \u0060cref:T:Starboard.K8s.KubeCtlWriter\u0060 to write a YAML (or JSON if you prefer) file that we can use to deploy our configuration to Kubernetes.\n\n\u003E Tip: \u0060__SOURCE_DIRECTORY__\u0060 contains a string to the directory the that the script file is running in.\n*)\n\n// write the file\nKubeCtlWriter.toYamlFile k8sConfig $\u0022{ __SOURCE_DIRECTORY__}{IO.Path.DirectorySeparatorChar}guestbook.yaml\u0022\n\n(**\n\nTest out the configuration you have created by applying it to your Kubernetes cluster. \n\n\u0060\u0060\u0060bash\nkubectl apply -f guestbook.yaml\nkubectl get all\n\u0060\u0060\u0060\n\nYou should see something similar to this:\n\n\u0060\u0060\u0060bash\nNAME                                  READY   STATUS    RESTARTS   AGE\npod/guestbook-7c9bfb4679-d8mzr        1/1     Running   0          29s\npod/guestbook-7c9bfb4679-jgqsk        1/1     Running   0          29s\npod/guestbook-7c9bfb4679-jrqb5        1/1     Running   0          29s\npod/redis-follower-75b578cb57-6bkcv   1/1     Running   0          29s\npod/redis-follower-75b578cb57-c6f4b   1/1     Running   0          29s\npod/redis-leader-5f6f4b8bb7-wqcz8     1/1     Running   0          29s\n\nNAME                     TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE\nservice/guestbook        NodePort    10.98.17.142    \u003Cnone\u003E        80:30762/TCP   29s\nservice/kubernetes       ClusterIP   10.96.0.1       \u003Cnone\u003E        443/TCP        22h\nservice/redis-follower   ClusterIP   10.99.147.198   \u003Cnone\u003E        6379/TCP       29s\nservice/redis-leader     ClusterIP   10.108.61.85    \u003Cnone\u003E        6379/TCP       29s\n\nNAME                             READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/guestbook        3/3     3            3           29s\ndeployment.apps/redis-follower   2/2     2            2           29s\ndeployment.apps/redis-leader     1/1     1            1           29s\n\nNAME                                        DESIRED   CURRENT   READY   AGE\nreplicaset.apps/guestbook-7c9bfb4679        3         3         3       29s\nreplicaset.apps/redis-follower-75b578cb57   2         2         2       29s\nreplicaset.apps/redis-leader-5f6f4b8bb7     1         1         1       29s\n\u0060\u0060\u0060\n\nTo test out the application, open up a port to 80, where the guestbook application is running.\n\n\u0060\u0060\u0060bash\nkubectl port-forward svc/guestbook 81:80\n\u0060\u0060\u0060\n\n\u003E 81 is the port you can access the app on your side. You can choose a port you prefer here.\n\nNavigate to [localhost:81](http://localhost:81/) and you should see the application.\n\n![Guestbook running](../img/tutorials/guestbook.png)\n\nGo ahead and leave a note.\n\n## Conclusion\n\nIn this tutorial we defined a more complicated configuration than [hello-world](hello-world.fsx). \n\n1. We saw how you can extract repetitive configuration into functions and then use that function to generate similar configuration multiple times.\n2. We also saw how using values allowed us to reuse those values by reference rather than having repeating values like names even when calling our functions.\n3. We demonstrated different styles available and say how we can not only compose resources like a Deployment but can also compose full Kubernetes configurations into combined ones.\n*)"}]